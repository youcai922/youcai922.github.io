#### Redis有哪些应用场景

Redis是基于C语言编写的，而且是内存中的数据库，读写速度很快。在项目中也经常会使用Redis，一般会用来做缓存、或者分布式锁，也可以来设计消息队列，同时还支持**事务 、持久化、Lua 脚本、多种集群方案。**

#### 你用Redis有哪些场景？使用的是哪些数据结构？

常见的有五种基本数据类型和三种特殊数据类型，

基本数据结构：String、 list、set、zset和hash，三种特殊数据类型：位图(bitmaps) 、计数器(hyperloglogs)和地理空间(geospatial indexes)。

String：一般常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。

list：发布与订阅或者说消息队列、慢查询。

hash：系统中对象数据的存储。

set：需要存放的数据不能重复以及需要获取多个数据源交集和并集等场景

zset：需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息。



#### Redis数据淘汰策略

- 定时删除：Redis启用定时任务监视所有的Key，这种策略可以保证过期的Key都会被删除，但是每次遍历的时候非常消耗CPU，而且存在已经过期了，但是未到达启动时间，这个时候是过期但是未删除的状态。
- 惰性删除：在获取Key的时候，判断Key是否过期，如果过期则删除。这种方式存在一个缺点，如果Key一直未使用，那么也是失效了，但是会一直保存在内存中。
- 定时删除+惰性删除：两个方法进行互补，但是定时删除不再是对所有的Key进行扫描，而是针对部分Key进行抽样检查。但是也会存在部分数据无法被检测到。
- 当内存满的时候，Redis会采用如下的内存淘汰机制：
  - noeviction（默认策略）：当内存不足以容纳写入的新的数据的时候，新写入操作就会报错。
  - allKeys-lru（推荐使用）：当内存不足以容纳新写入的数据的时候，在键空间移除最少使用的Key
  - allKeys-random：当内存不足以容纳新的写入的时候，随机移除某个Key
  - volatile-ttl：当内存不足的时候，在设置了过期时间的Key中，移除最少使用的Key
  - volatile-random：随即删除设置了过期时间的Key
  - volatile-ttl：在设置了过期时间的Key中，移除最早过期的Key

#### 应用场景

- 缓存：加快数据访问速度，减小数据库压力
- 共享Session：依赖于Session的服务，单机变集群的话，利用redis来统一管理session
- 消息队列系统：Redis提供了发布订阅功能和消息阻塞队列的功能。（List、redis订阅发布功能、Stream）
- 分布式锁：利用setnx编写分布式锁。
- 其他：
  - 点赞（利用缓存，统计一段时间的点赞量，减少后台更新次数）
  - 排行榜：https://blog.csdn.net/yinlidong77/article/details/121148044

#### Redis分布式锁

https://blog.csdn.net/weixin_43374578/article/details/123479567