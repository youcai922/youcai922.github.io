# List类

#### ArrayList和LinkedList区别

- ArrayList底层数组，插入删除慢，查找快；ArrayList主要控件开销在于需要在lList列表预留一定空间；
- LinkedList底层链表（双向链表），查找慢，插入删除快；LinkList主要控件开销在于需要存储结点信息以及结点指针信息。
- LinkedList和ArrayList都实现了List接口，但是LinkedList额外实现了Deque接口，可以当作队列使用

#### CopyOnWriteArrayList的底层原理是怎样的



# Map类

#### HashMap扩容机制

1.7版本

- 先生成数组
- 遍历老数组每个位置上链表的每个元素
- 去每个元素的key，并基于新数组长度，计算每个元素在新数组中的下标
- 将元素添加到新数组中去
- 所有元素转移完毕之后，将新数组赋值给HashMap对象的table属性

1.8版本

- 先生成新数组
- 遍历老数组中每个位置上的链表和红黑树
- 如果是链表，则直接将链表中每个元素重新计算下标，并添加到新数组中去
- 如果是红黑树，则先遍历红黑树，先计算出红黑树中每个元素对应在数组中的下标位置
  - 统计每个下标位置的元素个数
  - 如果该位置下的元素个数超过了8，则生成一个新的红黑树，并将根节点的添加到新数组的对应位置
  - 如果该位置下的元素个数没有超过8，那么则生成一个链表，并将链表的头节点添加到新数组的对应位置
- 所有元素转移完了之后，将新数组赋值给HashMap对象的table属性



#### HashMap扩容为什么是2的n次幂

数组下标的计算方法是(n - 1) & hash，**取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&)操作（也就是说 hash%length==hash&(length-1)的前提是 length 是2的 n 次方；）。”** 并且 **采用二进制位操作 &，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。**



#### HashMap的put方法

jdk1.7和1.8两个方面回答

- 根据key通过哈希算法与与运算得出数组下标

- 如果数组下标元素为空，则将key和value封装为Entry对象（JDK1.7是Entry对象，JDK1.8是Node对象）并放入该位置。

- 如果数组下标位置元素不为空，则要分情况
  - 如果是在JDK1.7，则**首先会判断是否需要扩容**，如果要扩容就进行扩容，如果不需要扩容就生成Entry对象，并使用**头插法**添加到当前链表中。
  - 如果是在JDK1.8中，则会先判断当前位置上的TreeNode类型，看是红黑树还是链表Node
    - 如果是红黑树TreeNode，则将key和value封装为一个红黑树节点并添加到红黑树中去，在这个过程中会判断红黑树中是否存在当前key，如果存在则更新value。
    - 如果此位置上的Node对象是链表节点，则将key和value封装为一个Node并通过尾插法插入到链表的最后位置去，因为是尾插法，所以需要遍历链表，在遍历过程中会判断是否存在当前key，如果存在则更新其value，当遍历完链表后，将新的Node插入到链表中，插入到链表后，会看当前链表的节点个数，如果大于8，则会将链表转为红黑树
    - 将key和value封装为Node插入到链表或红黑树后，在判断是否需要扩容，如果需要扩容，就结束put方法。

#### jdk1.8中HashMap底层链表转红黑树的阈值为什么是8？红黑树转链表为什么是6？

和hashcode碰撞次数的泊松分布有关，主要是为了寻找一种时间和空间的平衡。
红黑树中的TreeNode是链表中的Node所占空间的2倍，虽然红黑树的查找效率为o(logN)，要优于链表的o(N)，但是当链表长度比较小的时候，即使全部遍历，时间复杂度也不会太高。固，要寻找一种时间和空间的平衡，即在链表长度达到一个阈值之后再转换为红黑树。

之所以是8，是因为Java的源码贡献者在进行大量实验发现，hash碰撞发生8次的概率已经降低到了0.00000006，几乎为不可能事件，如果真的碰撞发生了8次，那么这个时候说明由于元素本身和hash函数的原因，此次操作的hash碰撞的可能性非常大了，后序可能还会继续发生hash碰撞。所以，这个时候，就应该将链表转换为红黑树了，也就是为什么链表转红黑树的阈值是8。

最后，红黑树转链表的阈值为6，主要是因为，如果也将该阈值设置于8，那么当hash碰撞在8时，会反生链表和红黑树的不停相互激荡转换，白白浪费资源。



#### hashmap是线程安全的吗

​	线程不安全，不安全的情况主要是resize()扩容方法导致的。主要体现如下：

- 在jdk1.7中，多线程环境下，扩容时会造成**环形链**或数据丢失。
- 在jdk1.8中，在多线程环境下，会发生**数据覆盖**的情况。



#### HashMap在计算hash值的时候为什么要右移16位

让HashMap更加均匀分布，阿里调优手册原文如下

![548572-20190628162239573-1588544244](https://youcai922.github.io/99.src/img/阿里调优手册-为什么HashMap计算hash值要右移16位.png)

![548572-20190628162239573-1588544244](https://youcai922.github.io/99.src/img/阿里调优手册-为什么HashMap计算hash值要右移16位2.png)

### ConcurrentHashMap

在jdk1.7是 **分段的数组+**链表 ，jdk1.8的时候跟HashMap1.8的时候一样都是基于数组+链表/红黑树。ConcurrentHashMap是线程安全的

- 在jdk1.7的时候是使用分段所segment，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。

- 在jdk1.8的时候摒弃了 Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 **CAS** 来操作。synchronized只锁定当前链表或红黑二叉树的首节点。

