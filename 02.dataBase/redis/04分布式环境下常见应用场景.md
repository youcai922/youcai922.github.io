## 分布式锁

当多个进程不在同一个系统中，如果我们在后台代码中利用synchronized或者Lock中加锁的方法进行加锁，那么在集群或者分布式的时候，此锁在这个时候只能单线程生效，所以我们需要一个中心化的锁----即分布式锁，那么这个时候就需要进行用分布式锁控制多个进程对资源的操作或者访问。与之对应有线程锁，进程锁。

分布式锁可以避免不同进程重复相同的工作，减少资源浪费。同时分布式锁可以避免破坏数据正确性的发生。例如多个进程对同一个订单操作，可能导致订单状态错误覆盖。

分布式实现方式有很多：

- 数据库乐观锁方式
- 基于redis的分布式锁
- 基于ZK的分布式锁

分布式锁实现要保证几个基本点：

- 互斥性：任意时刻只有一个资源能够获取到锁
- 容灾行：能够在未成功释放锁的情况下，一定时限内能够恢复锁的正常功能
- 统一性：加锁和解锁保证同一资源来进行操作

**应用场景一：定时任务重复执行**

例如每隔15分钟统计一下所有未支付的订单数量。这样启动定时任务的时候，肯定不能同一时刻多个业务后台服务都去执行定时任务。如果都去执行就很有可能导致重复计算。

这个时候就需要使用到分布式锁，进行资源的锁定。在执行定时任务的函数的时候，首先进行分布式锁的获取，如果可以获取到的话，则正常执行。那么其他的服务就获取不到锁，就无法执行定时任务了。

**应用场景二：避免用户重复下单**

客户利用不同的客户端同时去下订单，这个时候为了避免重复下单，就需要实现分布式锁

### Redis的分布式实现

redis中有个方法，setnx（set if not exists）命令在指定的KEY不存在的时候，为KEY设置指定的值。

```shell
1.获取锁setnx key value
2.执行业务逻辑
3.释放锁del key
```

基础版本的分布式锁逻辑存在一个问题如果我获得锁之后异常了，并没能够执行成功，不释放锁，那么资源则会一直被占用。

所以通常会在获取锁的时候添加一个过期时间

```sh
1.set key value ex 10 nx
2.执行业务
3.释放锁
```

![](https://youcai922.github.io/99.src/img/redis分布式锁.png)



## 分布式自增ID

当数据库进行分库分表操作的时候，我们在插入的时候，就无法使用自增id的形式了。因此，这个时候就需要使用分布式id生成器来提供唯一的id信息

通常对于分布式自增ID的实现方式有下面几种：

- 利用数据库自增ID的属性
- 通过UUID实现唯一ID生成
- Twitter的SnowFlake算法
- 利用Redis生成唯一ID

在这里我们自然是说Tedis来实现唯一ID的形式了。使用Redis的INCR命令来实现唯一ID

Redis是单进程单线程架构，不会因为多个取号方的INCR命令导致取号重复。因此，基于Redis的INCR命令实现序列号的胜场基本能满足全局唯一与单调递增的特性
