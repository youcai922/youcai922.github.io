### 布隆过滤器

一种数据结构，比较巧妙的概率型数据结构

特点：高效的插入和查询

相比较于传统的List、Set、Map等数据结构，他更高效、占用空间更少；缺点就是返回的结果是概率性的，而不是确切的。

通常来说：利用HashMap可以实现判断某个元素是否存在，但是HashMap实现也有缺点；比如存储容量占比高，考虑到负载因子的存在，通常空间是不能被用满的，而一旦你的值很多，例如上亿的时候，那HashMap占据的内存大小就变得很可观了。或者当数据集存储在远程的服务器，本地服务接受输入，而数据集非常大不可能一次性读进内存构建HashMap的时候，也会存在问题



优点：

- 空间和时间方面都有巨大优势
- 存储空间和插入/查询时间都是常熟

缺点：

- 误算率是其中之一，随着元素数量增加，误算率随之增加，如果元素太少，使用散列表就行了
- 不支持删除功能



### 布隆过滤器数据结构：

是一个bit向量或者说bit数组：

![img](https://pic002.cnblogs.com/images/2012/274814/2012071317402283.png)

原理就是根据布隆过滤器的三个不同的hash算法，计算x，y，z的三个hash值对应的地方是否为1，如果3个位置有一个不为1，则一定不存在，**如果三个位置都为1，那么是可能存在，而不是一定存在**，因为很有可能这三个地方被别的数覆盖掉了，如上图的y和z就有位置是重叠的。

#### 不支持删除操作：

传统的布隆过滤器并不支持删除操作，但是名为Counting Bloom Filter的变种可以用来测试元素计数个数是否绝对小于某个阈值，它支持元素删除。

Counting Bloom Filter它将标准Bloom Filter位数组的每一位扩展为一个小的计数器(Counter)，在插入元素时给对应的k(k为哈希函数个数)个Counter的值分别加1，删除元素时给对应的k个Counter的值分别减1，Counting Bloom Filter通过多占用几倍的存储空间的代价，给Bloom Filter增加了删除操作



#### 如何选择哈希函数个数和布隆过滤器长度

如果布隆过滤器的长度过小，就会导致很快所有的位数都变为了1，那么查询任何值都会返回**可能存在**，起不到过滤的效果，如果长度过长则会导致影响误报率，布隆过滤器越长，则误报率越小。

哈希函数的个数也需要权衡，如果个数越多，则布隆过滤器bit位置为1很快占满，且执行效率低，如果太少，误报率会变高。

最佳公式：

k 为哈希函数个数，m 为布隆过滤器长度，n 为插入的元素个数，p 为误报率

![img](https://pic1.zhimg.com/80/v2-1ed5b79aa7ac2e9cd66c83690fdbfcf0_720w.jpg)

