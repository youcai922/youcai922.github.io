#### 消息队列有那些作用

- 解耦：使用消息队列来作为两个系统之间的通讯方式，两个系统不需要互相依赖了
- 异步：系统A给消息队列发送完消息之后，就可以继续做其他事情了
- 流量削峰：如果使用消息队列的方式来调用某个系统，那么消息将在队列中排队，由消费者自己控制消费速度



#### 死信队列是什么？延时队列是什么？

- 死信队列也是一个消息队列，它用来存放那些没有成功消费的信息，通常可以用来作为消息重试
- 延时队列就是用来存放需要在指定时间被处理的元素的队列通常可以用来处理一些具有过期性操作的业务，比如十分钟内未支付则取消订单



#### Kafka为什么吞吐量高

Kafka的生产者采用的是异步发送消息机制，发送一条消息时，消息并没有发送到Broker而是缓存起来，然后直接向业务返回成功，当缓存的消息达到一定数量时再批量发送欸Broker。这种做法减少了网络IO，从而提高了消息发送的吞吐量，但是如果消息产生者宕机，则会导致消息丢失，业务出错，所以理论上Kafka利用此机制提高了性能却降低了可靠性



#### Kafka的Pull和Push分别由什么优缺点

- pull表示消费者主动拉取，可以批量拉取，也可以单条拉取，所以pull可以由消费者⾃⼰控制，根据⾃⼰的消息处理能⼒来进⾏控制，但是消费者不能及时知道是否有消息，可能会拉到的消息为空
- push表示Broker主动给消费者推送消息，所以肯定是有消息时才会推送，但是消费者不能按⾃⼰的 能⼒来消费消息，推过来多少消息，消费者就得消费多少消息，所以可能会造成⽹络堵塞，消费者 压⼒⼤等问题



#### RocketMQ的底层实现原理

RocketMQ由NameServer集群、Producer集群、Consumer集群、Broker集群组成，消息产生和消费的大致原理如下：

- Broker在启动的时候向所有NameServer注册，并保持长连接，每30s发送一次心跳
- Producer再发送消息的时候从NameServer获取Broker服务器地址，根据负载均衡算法选择一台服务器发送消息
- Conusmer消费信息的时候同样从NameServere获取Broker地址，然后主动拉去消息来消费



#### 消息队列如何保证消息可靠传输

消息可靠传输代表了两层意思，既不能多也不能少

- 为了保证消息不多，也就是消息不能重复，也就是⽣产者不能重复⽣产消息，或者消费者不能重复 消费消息
- ⾸先要确保消息不多发，这个不常出现，也⽐较难控制，因为如果出现了多发，很⼤的原因是⽣产 者⾃⼰的原因，如果要避免出现问题，就需要在消费端做控制
- 要避免不重复消费，最保险的机制就是消费者实现幂等性，保证就算重复消费，也不会有问题，通 过幂等性，也能解决⽣产者重复发送消息的问题
- 消息不能少，意思就是消息不能丢失，⽣产者发送的消息，消费者⼀定要能消费到，对于这个问 题，就要考虑两个⽅⾯
- ⽣产者发送消息时，要确认broker确实收到并持久化了这条消息，⽐如RabbitMQ的confirm机制,Kafka的ack机制都可以保证⽣产者能正确的将消息发送给broker
- broker要等待消费者真正确认消费到了消息时才删除掉消息，这⾥通常就是消费端ack机制，消费 者接收到⼀条消息后，如果确认没问题了，就可以给broker发送⼀个ack，broker接收到ack后才会删除消息

