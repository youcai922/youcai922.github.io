### 异步爬虫：

- 多线程、多进程（不推荐）：
- 线程池、进程池（适当使用）：

```python
import multiprocessing.dummy import Pool
def get_video_data(dic):

pool = Pool(4)
pool.map(get_video_data,urls)

pool.close()
pool.join()
```

- 单线程+异步协程（推荐）

  - event_loop：事件循环，相当于一个无限循环，可以把函数注册到这个事件循环上，当满足某些条件的时候，函数就会被循环执行

  - coroutine：协程对象，我们可以酱协程对象注册到事件循环中，它会被事件循环调用。

    我们可以使用 async 关键字来定义一个方法，这个方法在调用时不会立即被执行，而是返回一个协程对象。

  - task：任务：是协程对象的进一步分装，包含了任务的各个状态。
  - future：代表将来执行货还没开始执行的任务，实际上和task没有本质区别
  - async定义一个协程
  - await用来挂起阻塞方法 的执行



```python
import asyncio


async def request(url):
    print("正在请求", url)
    print('请求成功', url)


# async修饰的函数，调用之后会返回一个协程对象
c = request('www.baidu.com')
# 创建一个事件循环对象
loop = asyncio.get_event_loop()
# 将协程对象注册到loop中，然后启动loop
loop.run_until_complete(c)
```

```python
import asyncio


async def request(url):
    print("正在请求", url)
    print('请求成功', url)


# async修饰的函数，调用之后会返回一个协程对象
c = request('www.baidu.com')

# task的使用
loop = asyncio.get_event_loop()
# 基于loop创建了一个task对象
task = loop.create_task(c)
print(task)

loop.run_until_complete(task)

print(task)
```

```python
import asyncio


async def request(url):
    print("正在请求", url)
    print('请求成功', url)


# async修饰的函数，调用之后会返回一个协程对象
c = request('www.baidu.com')

# future使用
loop = asyncio.get_event_loop()
task = asyncio.ensure_future(c)
print(task)
loop.run_until_complete(task)
print(task)
```

```python
import asyncio


async def request(url):
    print("正在请求", url)
    print('请求成功', url)


# async修饰的函数，调用之后会返回一个协程对象
c = request('www.baidu.com')


def callback_func(task):
    #result返回的就是任务对象中封装的协程对象对应函数的返回值
    print(task.result())


# 绑定回调
loop = asyncio.get_event_loop()
task = asyncio.ensure_future(c)
# 将回调函数绑定到任务对象中
task.add_done_callback(callback_func)
loop.run_until_complete(task)
```

