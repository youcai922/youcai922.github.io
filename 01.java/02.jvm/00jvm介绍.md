### JVM内存模型：

![](https://img-blog.csdnimg.cn/20201021111601118.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l1Y2FuMTIzNA==,size_16,color_FFFFFF,t_70#pic_center)

![img](https://img-blog.csdnimg.cn/2021060411352293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70)

- **程序计数器**（线程私有）
  
  - 内存空间小
  - 是当前线程锁执行字节码的行号治时期，每条线程都有一个独立的程序计数器，这类内存也称为“线程私有”的内存。正在执行java方法的话，计数器记录的是虚拟机字节码指令的地址(当前指令的地址)。如果是Natice方法，则为空。
  - 是唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError情况的区域
  
- **虚拟机栈**（线程私有）
  
  - 生命周期和线程一致
  - 描述的是java方法执行的内存模型：每个方法在执行的时候也会创建一个栈帧，存储了局部变量，操作数，动态链接，方法返回地址。
  - 每个方法从调用到执行完毕，对应一个栈帧在虚拟机栈中的入栈和出栈。
  - 通常所说的栈，一般是指在虚拟机栈中的入栈和出栈
  - 局部变量所需内存在编译期间完成分配
  - 如果线程请求的栈深度大与虚拟机所允许的深度，则StackOverflowError
  - 虚拟机栈可以动态拓展，而扩展时无法申请到足够的资源。则OutOfMemoryError
  
- **本地方法栈**（线程私有）
  
  - 和虚拟机栈类似，主要为虚拟机使用到的Native方法服务，也会抛出StackOverflowError和OutOfMemoryError

- **堆**（线程共享）
  
  - 通常来叔，是jvm管理内存中最大的一块
  - 被所有线程共享的一块内存区域，在虚拟机启动的时候创建，用于存放对象实例和数组。
  - 对可以按照可拓展实现（通过-Xmx和-Xms来控制）
  - 当队中没有内存可分配给实例，也无法再拓展时，则抛出OutOfMemoryError异常

- **方法区**（线程共享）

  - 被所有方法线程共享的一块内存区域。
  - 用于存储已经被虚拟机加载的类信息，常量，静态变量等
  - 这个区域的内存回收目标主要是针对常量池的回收和堆类型的卸载。
  


### 类加载机制：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201021114445424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l1Y2FuMTIzNA==,size_16,color_FFFFFF,t_70#pic_center)

类加载机制分为五个部分：加载、验证、准备、解析、初始化

- 加载：加载是指将类的class文件读入到内存，并为之创建一个大的Class对象（java.lang.Class）对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。

  类的加载是由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。

  使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下集中来源。

  ```
  1.从本地文件系统加载class文件，这是前面绝大部分示例程序类加载方式
  2.从jar包加载class文件，这种方式也很常见。JVM可以从jar文件中直接加载class文件
  3.通过网络加载class文件
  4.把一个java源文件动态编译，并执行加载
  ```

  类加载器通常无需等到"首次使用"该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。

- 链接

  当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接负责把类的二进制数据合并到jre中。类连接又可分为如下三个阶段

  - 验证：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java时相对C++语言是安全的语言，例如C++不具有数据越界的检查。这本身就是对自身安全的一种保护，验证阶段是Java非常重要的阶段。他会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全，验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其中包括四种验证：文件格式验证，元数据验证，字节码验证，符号引用验证。

    ```
    文件格式验证：主要验证字节流是否符合Class文件格式规范，并且能被当前的虚拟机加载处理。例如：主，次版本号是否在当前虚拟机处理的范围之内。常量池中是否有不被支持的常量类型。指向常量的中的索引值是否存在不存在的常量或不符合类型的常量。
    
    元数据验证：对字节码描述的信息进行语义的分析，分析是否符合java的语言语法的规范。
    
    字节码验证：最重要的验证环节，分析数据流和控制，确定语义是合法的，符合逻辑的。主要的针对元数据验证后对方法体的验证。保证类方法在运行时不会有危害出现。
    
    符号引用验证：主要是针对符号引用转换为直接引用的时候，是会延伸到第三解析阶段，主要去确定访问类型等涉及到引用的情况，主要是要保证引用一定会被访问到，不会出现类等无法访问的问题。
    ```

  - 准备：类准备阶段负责为类的静态变量分配内存，并设置默认初始值

  - 解析：将类的二进制数据中的符号引用替换成直接引用。说明一下：
    - 符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关
    - 直接引用是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来。

- 初始化

  初始化是为类的静态变量赋予正确的初始值，准备阶段和初始阶段看似有点矛盾，其实是不矛盾的 ，如果类中有语句：private statci int a= 10；他的执行过程是这样的，首先字节码文件被加载到内存后，先进性链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认值0，即a=0，然后到解析，到初始化这一步骤时，才把a的正真值赋给a，此时a=10。



对象创建遵循如下过程：

当JVM遇到一条字节码new指令时，首先会去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，则会执行这个类的加载过程。在类加载过程完毕之后，虚拟机会为新生对象分配内存。对象所需内存的大小在类加载完成之后便可以完全确定，为对象分配内存空间的任务实际上就是将指定大小的内存从java堆中分配出来。内存划分完之后，虚拟机必须将分配的内存空间初始化为0，如果使用了TLAB的话，这项工作也可以提前至TLAB分配时顺便进行。这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。接下来，虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中。根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。在上面工作都完成之后，从虚拟机的视角来说一个新对象已经产生了。但是从Java序视角看来，对象创建才刚刚开始一一构造函数，即CIass文件中时init()>0．方法还没有执行，所有的字段都为默认的零值，对象需要貝他资源和状态信息也还没有按照顸定的意图构造好。所以new之后会跟随init方法，按照程序员的意图对对象进行初始化，这样一个对象才被创建出来。



### ClassLoader双亲委派

jvm类加载机制主要有如下三种：

- 全盘负责：

  所谓全盘负责，就是当一个类加载器负责加载某个class时，该class所依赖和引用其他class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。

- 双亲委派：

  所谓双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器服务加载该类时才会尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才会自己去加载。

- 缓存机制：
  缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区中。这就是为什么修改了Class之后，必须重新启动JVM，程序所作的修改才会生效的原因

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201101152833165.png#pic_center)

​	双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。

　　双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。





## JVM GC

### 垃圾回收算法：
**标记-清除算法**：

- 执行步骤：
  - 标记：遍历整个内存区域，对需要回收的对象打上标记
  - 清除：再次遍历内存，对标记过的内存进行回收
- 缺点：
  - 效率问题：便利了两次内存空间
  - 空间问题：容易产生大量的内存碎片，当在需要一块比较大的内存时，虽然总的可用内存还是够的，但是由于太过于分散，无法找到一块连续且满足分配需要的，因为不得不再次触发一次GC

**复制算法：**

- 执行步骤：

  将内存划分为两个等大的两块，每次只使用其中的一块。当一块用完了，触发GC时，该块中存货的对象复制到另一块区域，然后一次性清理掉这块没有用的内存。下次触发GC时将那块存活的又复制到这块，然后抹掉那块，反复循环

- 优点：

  - 相对于标记-清理算法解决了内存的碎片化问题，因为复制的时候，会把存活的对象，聚拢在一起。
  - 效率更高（清理内存时，记住首尾地址，一次性抹掉）

- 缺点：

  - 内存利用率不高，每次只能使用一半内存。8G的内存，只能使用4G，这个是无法接收的。

- 优化：研究表明，大多数对象都是“朝生夕死”，生命周期非常短。即说明，在发生GC的时候，大多数的对象已经是带回收了，还处于正常状态的对象很少，因为存货的特别少，所以在进行复制的时候，复制的对象就特别少，占用的空间也就特别小，完全不需要1：1划分空间。多了也是浪费，够分配就行。

  但是也有一部分对象生命周期特别长，比如缓存中的对象，还有一些别的对象等等，对于这些对象如果每次都要复制移动的话，就显得特别麻烦。另外如果某些对象特别大，如果复制的话，也放不下。根据对象的特点进行分治。将整个堆分为两个大块：新生代和老年代，分别存放不同特点的对象

  **新生代就是存放生命周期短的对象及体积小的对象。老年代就是存放生命周期长的，体积大的对象。**

  将整个新生代按照8：1：1的比例划分为三块，最大的成为Eden（伊甸园）区，最小的两块分别称为To Survivor和From Survivor

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/5ff51668dd3cbe6826d7cc51b166066b.png)

  首次GC时，只需要将Eden存活的对象复制到To。然后将Eden区整体回收，再次GC时，将Eden和To存货的复制到From，循环往复这个过程。这样每次新生代中可用的内存就占整个新生代的90%，大大提高了内存利用率。

  但不能保证每次存活的对象就永远少于新生代整体10%，此时复制过去是存不下的。因此这里会用到老年代，进行**分配担保**，存不下的话就将对象存储到老年代，若还不够，就会抛出OOM。另外如果一个对象在多次内存回收后，都还存活，也会进入老年代，这个次数通过-XX：+MaxTenuringThreshold控制，最大值为15（对象头中4个bit存放）

**标记-整理算法:**

当对象的存活率比较高的时候，或者对象比较大的时候，用前面的复制算法，复制过来复制过去，没什么意义，还浪费时间，所以针对老年代提出了标记整理算法

- 执行步骤：
  - 标记：对需要回收的进行标记
  - 整理：让存活的对象，向内存的一端移动，然后直接清理掉没有用的内存

**分代收集算法：**

分代收集算法就是上面新生代和老年代根据对象不同的特点，采用不同的算法进行回收，取名为分代收集。



