#### Kafka介绍

​	Kafka是由Scala和Java编写的一个开源流处理平台。Kafka是一种高吞吐量的**分布式发布订阅消息系统**，它可以处理消费者规模的网站中的所有动作流数据。 这种动作（网页浏览，搜索和其他用户的行动）是在现代网络上的许多社会功能的一个关键因素。 这些数据通常是由于吞吐量的要求而通过处理日志和日志聚合来解决。 对于像Hadoop的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。Kafka的目的是通过Hadoop的并行加载机制来统一线上和离线的消息处理，也是为了通过集群来提供实时的消息。

#### 消息队列

- 点对点模式的消息队列

  对一个消息而言，只会有一个消费者可以消费，消费者主动拉取消息，消息收到后，会将消息删除

- 基于发布/订阅的消息队列

  发布到topic的消息会被所有订阅者消费，消费者消费完消息后不会删除

- 消息队列主动推送

  适用于消费者处理能力高，生产者生产消息较少的场景，整个系统的消息处理速度由消息队列的推送速度决定，多个消费者之间处理消息的能力不同，如果消息队列按照一定的速度推送消息

- 消费者主动拉取



#### 基础架构及术语

![img](https://www.17coding.info/cdn/WeChat%20Screenshot_20190325215237.png)



- **Producer**：Producer即生产者，消息的产生者，是消息的入口。

- **kafka cluster**：
  - **Broker**：Broker是kafka实例，每个服务器上有一个或多个kafka的实例，我们姑且认为每个broker对应一台服务器。每个kafka集群内的broker都有一个**不重复**的编号，如图中的broker-0、broker-1等……
  - **Topic**：消息的主题，可以理解为消息的分类，kafka的数据就保存在topic。在每个broker上都可以创建多个topic。
  - **Partition**：Topic的分区，每个topic可以有多个分区，分区的作用是做负载，提高kafka的吞吐量。同一个topic在不同的分区的数据是不重复的，partition的表现形式就是一个一个的文件夹！
  - **Replication**:每一个分区都有多个副本，副本的作用是做备胎。当主分区（Leader）故障的时候会选择一个备胎（Follower）上位，成为Leader。在kafka中默认副本的最大数量是10个，且副本的数量不能大于Broker的数量，follower和leader绝对是在不同的机器，同一机器对同一个分区也只可能存放一个副本（包括自己）。
  - **Message**：每一条发送的消息主体。
- **Consumer**：消费者，即消息的消费方，是消息的出口。
- **Consumer Group**：我们可以将多个消费组组成一个消费者组，在kafka的设计中同一个分区的数据只能被消费者组中的某一个消费者消费。同一个消费者组的消费者可以消费同一个topic的不同分区的数据，这也是为了提高kafka的吞吐量！
- **Zookeeper**：kafka集群依赖zookeeper来保存集群的的元信息，来保证系统的可用性。

微博的博主就像Broker，Broker在微博上生产内容，但是内容指定主题（Topic），主题下面有分区（Partition），内容就是Message。

在一个时间段内，一个消费者只能消费一个分区。
