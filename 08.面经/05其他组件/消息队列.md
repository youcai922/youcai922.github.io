#### MQ的作用：

- 解耦：将消息写入消息队列，需要消息的时候自己从消息队列中订阅，从而原系统不需要做任何修改。

- 异步：将消息写入消息队列，非必要的业务逻辑以异步的方式运行，加快响应速度

- 削峰：原系统慢慢的按照数据库能处理的并发量，从消息队列中慢慢拉取消息。在生产中，这个短暂的高峰期积压是允许的。

#### 缺点：

- 系统可用性降低
  系统引入的外部依赖越多，越容易挂掉。万一 MQ 挂了，MQ 一挂，整套系统崩溃，你不就完了？

- 系统复杂度提高（需要保证消息不会重复消费，消息是否丢失，消息传递顺序等等等等）

- 一致性问题
  A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，这个时候数据就不一致了。



#### 面对秒杀峰值的策略？

- 合法性限流：针对非正常请求（脚本）进行限流，添加验证码。多次购买同一件物品，并且购买间隔时间非常短，则判定为非正常请求，对其进行限流
- 负载限流：Nginx针对访问分发到不同的主机上进行处理，除此之外还有硬件负载
- Web服务器本身的限流：
  - 设置web服务器（tomcat）最大连接数
  - 设置token令牌生成数量，无令牌无法进行访问
- 消息队列：超过一定数量之后进入等待队列
- 缓存：将部分处理放到客户端

读峰值策略？写峰值策略？



#### RabbitMQ集群架构

https://www.jianshu.com/p/b7cc32b94d2a



#### 消息队列有那些作用

- 解耦：使用消息队列来作为两个系统之间的通讯方式，两个系统不需要互相依赖了
- 异步：系统A给消息队列发送完消息之后，就可以继续做其他事情了
- 流量削峰：如果使用消息队列的方式来调用某个系统，那么消息将在队列中排队，由消费者自己控制消费速度



#### 死信队列是什么？延时队列是什么？

- 死信队列也是一个消息队列，它用来存放那些没有成功消费的信息，通常可以用来作为消息重试
- 延时队列就是用来存放需要在指定时间被处理的元素的队列通常可以用来处理一些具有过期性操作的业务，比如十分钟内未支付则取消订单



#### Kafka为什么吞吐量高

Kafka的生产者采用的是异步发送消息机制，发送一条消息时，消息并没有发送到Broker而是缓存起来，然后直接向业务返回成功，当缓存的消息达到一定数量时再批量发送欸Broker。这种做法减少了网络IO，从而提高了消息发送的吞吐量，但是如果消息产生者宕机，则会导致消息丢失，业务出错，所以理论上Kafka利用此机制提高了性能却降低了可靠性



#### Kafka的Pull和Push分别由什么优缺点

- pull表示消费者主动拉取，可以批量拉取，也可以单条拉取，所以pull可以由消费者⾃⼰控制，根据⾃⼰的消息处理能⼒来进⾏控制，但是消费者不能及时知道是否有消息，可能会拉到的消息为空
- push表示Broker主动给消费者推送消息，所以肯定是有消息时才会推送，但是消费者不能按⾃⼰的 能⼒来消费消息，推过来多少消息，消费者就得消费多少消息，所以可能会造成⽹络堵塞，消费者 压⼒⼤等问题



#### RocketMQ的底层实现原理

RocketMQ由NameServer集群、Producer集群、Consumer集群、Broker集群组成，消息产生和消费的大致原理如下：

- Broker在启动的时候向所有NameServer注册，并保持长连接，每30s发送一次心跳
- Producer再发送消息的时候从NameServer获取Broker服务器地址，根据负载均衡算法选择一台服务器发送消息
- Conusmer消费信息的时候同样从NameServere获取Broker地址，然后主动拉去消息来消费



#### 消息队列如何保证消息可靠传输

消息可靠传输代表了两层意思，既不能多也不能少

- 为了保证消息不多，也就是消息不能重复，也就是⽣产者不能重复⽣产消息，或者消费者不能重复 消费消息
- ⾸先要确保消息不多发，这个不常出现，也⽐较难控制，因为如果出现了多发，很⼤的原因是⽣产 者⾃⼰的原因，如果要避免出现问题，就需要在消费端做控制
- 要避免不重复消费，最保险的机制就是消费者实现幂等性，保证就算重复消费，也不会有问题，通 过幂等性，也能解决⽣产者重复发送消息的问题
- 消息不能少，意思就是消息不能丢失，⽣产者发送的消息，消费者⼀定要能消费到，对于这个问 题，就要考虑两个⽅⾯
- ⽣产者发送消息时，要确认broker确实收到并持久化了这条消息，⽐如RabbitMQ的confirm机制,Kafka的ack机制都可以保证⽣产者能正确的将消息发送给broker
- broker要等待消费者真正确认消费到了消息时才删除掉消息，这⾥通常就是消费端ack机制，消费 者接收到⼀条消息后，如果确认没问题了，就可以给broker发送⼀个ack，broker接收到ack后才会删除消息

