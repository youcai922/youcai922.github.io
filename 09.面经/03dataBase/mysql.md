#### 什么是事务，事务的四个特性（ACID）

事务是指是程序中一系列严密的逻辑操作，而且所有操作必须全部成功完成，否则在每个操作中所作的所有更改都会被撤消。

事务的四个特性：

- 原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。
- 一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。
- 隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。
- 持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。

#### 事务的并发问题

- 脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据
- 幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。
- 不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。
- 不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表

#### 事务隔离机制

- 读已提交：允许事务查看其他事务所进行的未提交更改		
- 读未提交：允许其他事务查看已经提交的事务						避免了脏读
- 可重复读：commit之后，其他窗口看不到数据，必须退出重新登录查看				避免了脏读和不可重复读
- 串行化：将一个事务于其他事务完全隔离								避免了脏读，幻读和不可重复读

#### 

#### 索引分类

- 单列索引

  - 普通索引（index）：Mysql基本索引类型，允许重复和空
  - 唯一索引（unique）：允许为空，不可以重复
  - 主键索引（primary key）：不允许为空

  ```sql
  #添加索引
  CREATE INDEX index_name ON table(column(length)) ; 
  ALTER TABLE table_name ADD INDEX index_name (column(length)) ;
  ```

- 组合索引：多列组合进行索引，遵循最左前缀原则

  ```sql
  ALTER TABLE article ADD INDEX index_titme_time (title(50),time(10)) ;
  ```

- 全文索引：索引执行的优先级高

- 空间索引：一般用不到

#### 索引优缺点：

优点：

- 大大加快数据的检索速度;
- 创建唯一性索引，保证数据库表中每一行数据的唯一性;
- 加速表和表之间的连接;
- 在使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间。

缺点：

- 索引需要占物理空间。
- 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度。

#### 什么时候适合索引

根据索引的优缺点可以知道，索引也会占用资源。随意我们适合在增删频率少的表进行索引操作。

####  删除百万级的数据需要注意什么

先删除索引，然后删除指定数据，然后再重新简历索引

#### 聚簇索引和非聚簇索引

聚集索引是指数据库表行中数据的物理顺序与键值的逻辑（索引）顺序相同。一个表只能有一个聚集索引，因为一个表的物理顺序只有一种情况，所以，对应的聚集索引只能有一个。如果某索引不是聚集索引，则表中的行物理顺序与索引顺序不匹配，与非聚集索引相比，聚集索引有着更快的检索速度。

#### 索引的数据结构：B+树

#### 索引失效

- not in会全表扫描，推荐使用not exit
- 不遵循最左前缀原则
- like通配符使用 ‘%’开头
- 在索引列进行  计算，函数，手动或自动的类型转换
- 老版本的<>或！=或is null 或 is not null
- 字符串不加单引号也会导致索引失效，类似自动做了类型转换



#### union和union all

union会对结果进行一个去重并且排序，union all则不会

#### in和exist的区别

exit函数返回的是真和假，

外层查询表小于子查询表，则用exists，外层查询表大于子查询表，则用in

```sql
SELECT * FROM `user` WHERE id in (SELECT user_id FROM `order`)
```

in语句只会执行一次，然后查出order表所有的user_id字段并且缓存起来，然后检查user表的id是否和user_id相等，如果相等，则加入结果集。知道遍历完user的所有记录。

exit关键字则会执行user.length次，它并不会去缓存结果集，而是每次都去判断当前数据是否存在于order表中。

所以，当外层查询小于内层查询，更加适合用exit。相反，则用in



#### group by和order by执行顺序

写的顺序：select ... from... where.... group by... having... order by..

执行顺序：from... where...group by... having.... select ... order by...

#### having和where

having是对返回结果集的一个筛选，而where则是查询结果集的条件。简单来说，where是在返回之前，而having是在返回之后，展示之前。

- having的条件必须显示的声明
- where不可以使用聚合函数，having可以
- having晚于group by，where早于group by

