#### 三大范式
​       1、1NF:字段不可分，每个字段是原子级别的，比如一个字段为ID，它不能在分成两个字段了，不能说我要把这个人的ID、名称、班级号都塞在一个字段里面，这个是不合适的，对以后的应用造成很大影响；
　　2、2NF:有主键，非主键字段依赖主键，ID字段就是主键，它能表示这一条数据是唯一的，有的读者朋友记性很好，“unique”表示唯一的、不允许重复的，确实它经常会修饰某个字段，保证该字段唯一性，然后再设置该字段为主键；
　　3、3NF:非主键字段不能相互依赖，这个怎么理解呢，比如student表，班级编号受人员编号的影响，如果在这个表中再插入班级的班主任、数学老师等信息，你们觉得这样合适吗？肯定不合适，因为学生有多个，这样就会造成班级有多个，那么每个班级的班主任、数学老师都会出现多条数据，而我们理想中的效果应该是一条班级信息对应一个班主任和数学老师，这样更易于我们理解，这样就形成class表，那么student表和class表中间靠哪个字段来关联呢，肯定是通过“classNo”，这个字段也叫做两个表的外键；

#### Sql语句执行过程：

![sql执行过程](https://img-blog.csdnimg.cn/20201006090853757.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l1Y2FuMTIzNA==,size_16,color_FFFFFF,t_70#pic_center)

#### 视图：

视图是一种虚拟存在的表，是一个逻辑表，本身并不包含数据。作为select语句保存在数据字典中。

使用场景：查询语句比较复杂，或者经常使用的查询语句

```sql
创建语法
Create view 视图名 as 查询语句
显示视图创建情况
show create view 视图名;
查看视图
Show tables；
Show table status [ from db_name ] [ like ‘pattern’ ]；
SELECT * FROM information_schema.views where table_name = 'my_view';
删除视图
drop view 视图名[,视图名…];
重命名视图
Rename table 视图名 to 新视图名;
```

- 优点：
  - 安全性
  - 简化数据操作，提高操作效率
  - 合并分离的数据，创建分区视图
- 缺点
  - 性能差
  - 限制修改

#### explain

````sql
explain + 完整的sql语句
````

查询的结果有12个字段

- Id
  Sql的执行顺序的优先级，是相同，则从上到下依次执行
  如果不相同，则先执行id大的
  有的一条语句有子查询，id的序号会递增，所以子查询会先执行，在执行外层语句
- select_type
  每个查询字句的类型
  (1) SIMPLE(简单SELECT，不使用UNION或子查询等)
  (2) PRIMARY(子查询中最外层查询，查询中若包含任何复杂的子部分，最外层的select被标记为PRIMARY)
  (3) UNION(UNION中的第二个或后面的SELECT语句)
  (4) DEPENDENT UNION(UNION中的第二个或后面的SELECT语句，取决于外面的查询)
  (5) UNION RESULT(UNION的结果，union语句中第二个select开始后面所有select)
  (6) SUBQUERY(子查询中的第一个SELECT，结果不依赖于外部查询)
  (7) DEPENDENT SUBQUERY(子查询中的第一个SELECT，依赖于外部查询)
  (8) DERIVED(派生表的SELECT, FROM子句的子查询)
  (9) UNCACHEABLE SUBQUERY(一个子查询的结果不能被缓存，必须重新评估外链接的第一行)

- table
  这一步访问的数据库中表的名称，有可能是简称

- type
  找到所需行的方式，又称访问类型
  ALL、index、range、 ref、eq_ref、const、system、NULL（从左到右，性能从差到好）

```sql
ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行
index: Full Index Scan，index与ALL区别为index类型只遍历索引树
range:只检索给定范围的行，使用一个索引来选择行
ref: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值
eq_ref: 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件
const、system: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量，system是const类型的特例，当查询的表只有一行的情况下，使用system
NULL: MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。
```

- Possible_keys
  指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用（该查询可以利用的索引，如果没有任何索引显示 null）

- Key
  实际决定使用的键(索引)，包含于possible_keys

- Key_len
  索引中使用的字节数，可以通过该列计算查询中使用的索引的长度(key_len的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出来的)
  在不损失精度的情况下，长度越短越好

- ref
  列与索引的比较，表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值

- rows
  估算出结果集行数，表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数

- Extra
  不用读取表的信息，仅通过索引就能获取到的数据

#### 事务

事务的四个特性：

- **原子性（Atomicity，或称不可分割性）:**一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
- **一致性（Consistency）:** 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。
- **隔离性（Isolation，又称独立性）:**数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。
- **持久性（Durability）:**事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

#### 事务的隔离机制

​	数据库系统必须具有隔离并发运行各个事务的能力，使他们互不影响，避免各种并发问题。一个事务与其他事务的隔离程度称为隔离级别。SQL标准中规定了多种事务隔离级别，不同的隔离级别对应不同的干扰程度，隔离级别越高，数据一致性就越好，但并发性就越弱。

**读未提交 READ UNCOMMITTED**
允许一个事务读取另一个事务没有提交的数据

**读已提交 READ COMMITTED**
要求一个事务只能读取其他事务已经提交的修改

**可重复读 REPEATABLE READ**
确保一个事务可以多次从一个字段中读取到相同的值，即这个事务执行期间禁止其他事务对这个字段进行更新

**串行化 SERILIZABLE**
确保一个事务可以从一个表中读取到相同的行，在事务A执行期间，禁止其他事务对这个表进行添加，更新，删除操作，可以避免发生任何并发问题，但是性能十分低

**脏读，幻读，不可重复读**
**脏读**
	事务A将某条记录修改了值i为20，但是还没有提交
	事务B读取了被事务A修改后的值i=20
	事务A出现了异常进行回滚，将值改回了原来的10
	事务B读取到了20就是一个无效的值，俗称脏数据
**不可重复读**
	事务A读取i值为10
	事务B将i的值修改为20，已经提交
	事务A再次读取i的值为30
	事务A两次读取到的数据不一样
**幻读**
	事务A读取了表中的一部分数据
	事务B向表中插入了新的行
	事务A再次读取表的数据时，发现出现了新的行